COUNTER


library IEEE;
use IEEE.STD_LOGIC_1164.ALL;
use IEEE.NUMERIC_STD.ALL;
entity registers is
    Port ( clk  : in  STD_LOGIC;
           il   : in  STD_LOGIC;
           ir   : in  STD_LOGIC;
           rst  : in  STD_LOGIC;
           mode : in  STD_LOGIC_VECTOR (1 downto 0);
           i    : in  STD_LOGIC_VECTOR (3 downto 0);
           q    : out STD_LOGIC_VECTOR (3 downto 0));
end registers;
architecture Behavioral of registers is
    signal qtmp : STD_LOGIC_VECTOR(3 downto 0) := "0000";
begin
    process(clk, rst)
    begin
        if rst = '1' then
            qtmp <= "0000";
        elsif rising_edge(clk) then
            case mode is
                when "00" => qtmp <= qtmp;  -- Hold
                when "01" => qtmp <= i;     -- Load input
                when "10" => qtmp <= qtmp(2 downto 0) & ir;  -- Left shift
                when "11" => qtmp <= il & qtmp(3 downto 1);  -- Right shift
                when others => null;
            end case;
        end if;
    end process;
    q <= qtmp;
end Behavioral;




code for testbench:
LIBRARY ieee;
USE ieee.std_logic_1164.ALL;
ENTITY registers_tb IS
END registers_tb;
ARCHITECTURE behavior OF registers_tb IS 
    -- Component Declaration
    COMPONENT registers
    PORT(
         clk : IN  std_logic;
         il : IN  std_logic;
         ir : IN  std_logic;
         rst : IN  std_logic;
         mode : IN  std_logic_vector(1 downto 0);
         i : IN  std_logic_vector(3 downto 0);
         q : OUT std_logic_vector(3 downto 0)
        );
    END COMPONENT;
    -- Signals
    signal clk : std_logic := '0';
    signal il : std_logic := '0';
    signal ir : std_logic := '0';
    signal rst : std_logic := '0';
    signal mode : std_logic_vector(1 downto 0) := (others => '0');
    signal i : std_logic_vector(3 downto 0) := (others => '0');
    signal q : std_logic_vector(3 downto 0);
    constant clk_period : time := 40 ns;
BEGIN
    -- Instantiate the UUT
    uut: registers PORT MAP (
          clk => clk,
          il => il,
          ir => ir,
          rst => rst,
          mode => mode,
          i => i,
          q => q
        );
    -- Clock generation process
    clk_process :process
    begin
        while true loop
            clk <= '0';
            wait for clk_period / 2;
            clk <= '1';
            wait for clk_period / 2;
        end loop;
    end process;
    -- Stimulus process
    stim_proc: process
    begin
        -- Apply reset
        rst <= '1';
        wait for 60 ns;
        rst <= '0';
        -- Load data
        i <= "1010";  wait for 40 ns;
        -- Hold mode
        mode <= "00"; wait for 40 ns;
        -- Load mode
        mode <= "01"; wait for 40 ns;

     -- Left shift
        mode <= "10"; 
        ir <= '1'; wait for 40 ns;
        -- Right shift
        mode <= "11"; 
        il <= '1'; wait for 40 ns;
        -- End of simulation
        wait;
    end process;
END behavior;





 
